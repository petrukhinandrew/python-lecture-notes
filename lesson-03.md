# Занятие 3. 03.11. Что ещё может нам пригодиться

Все кусочки кода лучше запускать самостоятельно и проверять на своих примерах. Программирование - это бесчисленное множество проб, ошибок, переписывания кода и исследования форумов!

## Напоминание

Наверное, вы уже знакомы с функциями `id()` и `type()`. Вспомните еще раз, что они делают!

## Вернемся к числам

### Множественное присваивание

На первом занятии мы успели затронуть идею, что в python можно написать вот так:

```python
a, b = int(input()), int(input())
```

И python действительно корректно считает два числа в двух строчках

**Мысль 1.** Такая конструкция распространяется на большее число переменных:

```python
a, b, c, d = int(input()), int(input()), int(input()), int(input())
```
**Мысль 2.** Такую конструкцию можно использовать, чтобы "обменять" значения двух переменных

```python
a = 5
b = 10
a, b = b, a
print(b) # 5
print(a) # 10

# конечно, можно завести еще одну переменную и написать
a = 5
b = 10
tmp_var = a
a = b
b = tmp_var
print(a) # 10
print(b) # 5
# но нам потребовалось целых три строчки!
```

### Тернарный оператор

Представим, что в зависимости от некоторого условия `условие` переменная `переменная` должна быть 5 или 10 в некоторый момент выполнения программы.

Сейчас мы умеем писать условия, сделаем это:

```python
условие = True

if условие:
    переменная = 5
else:
    переменная = 10

print(переменная) # 5
```

В python подумали: "Зачем для такого короткого условия писать такую громоздкую конструкцию? Давайте сделаем сокращенную форму!"

```python
условие = True

значение_если_условие_выполнено = 5
значение_если_условие_НЕ_выполнено = 10

переменная = значение_если_условие_выполнено if условие else значение_если_условие_НЕ_выполнено 

print(переменная) # 5
```

Наверное, сразу понятно, что внутри такого условия могут быть различные `not, and, or, ...`. Но вот возникает вопрос: можно ли писать такие штуки вложенными? Ну, например, нужно сделать переменную x 
- равной 3, если число делится только на 3
- равной 8, если число делится на 3 и 5
- равной 2, если число делится на 2 и не делится на 3
- равной 7, если число делится на 2 и 5, но не делится на 3

Такая задача остается вам в качестве упражнения. Её нужно решить, используя тернарный оператор. Это возможно, правда-правда!

### `min()`, `max()`
Найти минимальное среди двух чисел довольно просто:

```python
a = 1
b = 2
minimum = 0
if a < b:
    minimum = a
else:
    minimum = b
print(minimum)# 1
```

Если чисел больше, чем 2, условие будет разрастаться. Нам такого точно не хочется.

Разработчики python позаботилисьо пользователях и придумали функции, названия которых говорят сами за себя

```python
a = 1
b = 2
minimum = min(a, b) # 1
maximum = max(a, b) # 2

# функциям min и max нет дела, сколько аргументов вы им передадите
print(min(7,6,5,4,3,2,1)) # 1
print(max(7,6,5,4,3,2,1)) # 7

# эти функции умеют даже обрабатывать списки!
my_list = [1, 3, 5, 7, 9]
print(min(my_list)) # 1
print(max(my_list)) # 9
```

А давайте соединим наши знания о множественном присваивании и функциях `max()` и `min()`:

```python
a = 15
b = 10
a, b = min(a, b), max(a, b)
print(a, b) # 10 15
```

Вот так ловко мы научились преобразовывать две переменные так, что первая из них будет минимумом, а вторая - максимумом

## Снова строки

### `upper()`, `lower()`
Мы как-то писали решение для задачи кодирования строки шифром Цезаря. Это тот шифр, который сдвигает буквы на несколько позиций в алфавите. Но вот проблема, пользователь не понял, что можно вводить строчки только из маленьких букв. Решим эту проблему функцией `lower`

```python
my_string = "СтРоЧкА"
my_lower_string = my_string.lower()
print(my_lower_string) # "строчка"
# НО
my_string.lower()
print(my_string) # "СтРоЧкА"
```

Обратную операцию можно выполнить используя `upper

```python
my_string = "СтРоЧкА"
my_upper_string = my_string.upper()
print(my_upper_string) # "СТРОЧКА"
# НО
my_string.upper()
print(my_string) # "СтРоЧкА"
```

Важно помнить, что эти функции не меняют саму строчку! 

### `split()`

У нас снова проблема! Теперь пользователь хочет кодировать имя и фамилию сразу! Программисты точно не хотят проверять каждый символ, если это пробел или нет! Они используют `split()`!

```python
full_name = "пользователь второй"
name_parts = full_name.split() # ["пользователь", "второй"]

another_full_name = input() # ввели : "Иван Иванов"
another_name_parts = another_full_name.split() # ["Иван", "Иванов"]

# Почему бы не соединить?
name = input().split() # ввод "Имя Фамилия" сразу превратится в ["Имя", "Фамилия"]
print(name) # ["Имя", "Фамилия"]
```
### `strip()`

Пользователь отвлекся и ввёл лишних пробелов нашей программе. Научимся это исправлять функцией `strip()`

```python
name = "               User                 "
print(name) # "               User                 "
print(name.strip) # "User"
```

А если мы хотим удалять пробелы **только слева** или **только справа** ? Почти то же самое!

```python
name = "               User                 "
print(name) # "               User                 "
print(name.rstrip()) # "               User"
print(name.lstrip()) # "User                 "
```

Мы просто добавили к `strip` - `l` (left == лево) и `r` (right == право), чтобы удалять пробелы слева или справа соответственно

Тут тоже следует заметить, что ни `split()`, ни `strip()` не изменяют строку! 
```python
name = "               User                 "
name.lstrip()
name.rstrip()
name.strip()
print(name) # "               User                 "
```

## Ещё раз про циклы

Возникают ситуации, когда нужно быстро выйти из цикла и продолжать выполнение программы. В таких случаях используют `break`

```python
for i in range(1, 10):
    if i == 5:
        break
    print(i, end=" ")
# Напечатает "1 2 3 4 "

i = 1
while i < 10:
    print(i, end=" ")
    if i == 4:
        break
# Напечатает "1 2 3 4 "
```
*Замечание:* обратите вниимание на порядок: 
- В первом случае сначала проверяем на равенство, а потом печатаем
- Во втором случае сначала печатаем, а потом проверяем на равенство

А теперь нам нужно "пропустить" выполнение одной "итерации" цикла, одного как бы круга выполнения. Пригодится `continue`

```python
for i in range(1, 10):
    if i == 7:
        continue
    print(i, end=" ")
# Напечатает "1 2 3 4 5 6 8 9"
```

**Но обратите внимание!**

```python
for i in range(1, 10):
    print(i, end=" ")
    if i == 7:
        continue
# Напечатает "1 2 3 4 5 6 7 8 9"
```
**В последнем случае 7 всё-таки напечатана!** Это снова связано с тем, что мы сначала напечатали число, а только потом проверили его на равенство семи.

А вот, кстати, вариант, как делать не стоит, цикл может выполняться бесконечно!

```python
i = 1
while i < 10:
    if i == 4:
        continue
    print(i, end=" ")
# Напечатает "1 2 3 " и зависнет!
```

## Списки и хитрости с ними

### `in`

Мы умеем хранить список. Допустим, нужно проверить, что в нём содержится какой-то элемент. Как можно это сделать?

Циклы уже пройдены, можно воспользоваться ими:

```python
my_list = [1, 2, 7, "строка", "пользователь", 3.14, 2.71]
elem_to_find = "строка"
elem_found = False
for elem in my_list:
    if elem == elem_to_find:
        elem_found = True
        break

print(elem_found) # True

elem_to_find = 3
elem_found = False
for i in range(0, len(my_list) - 1):
    if elem == my_list[i]:
        elem_found = True
        break

print(elem_found) # False
```

Но в python пошли дальше. Смотрите, как всё оказывается просто:

```python
my_list = [1, 2, 7, "строка", "пользователь", 3.14, 2.71]
elem_to_find = "строка"

elem_found = elem_to_find in my_list
print(elem_found) # True

elem_to_find = 100500
elem_found = elem_to_find in my_list
print(elem_found) # False
```

Да, как в английском языке! `in` позволяет проверить, если element `in` list, то есть элемент `в` списке. И не нужны длинные циклы!

### Срезы или slice

До этого мы умели делать операции только с целыми списками. Но, предположим, нам нужно посмотреть только на небольшой кусочек из серединки. Понадобится конструкция, которая похожа на доступ по индексу:

```python
my_list = [0, 1, 2, 3, 4, 5, 6]
print(my_list[1 : 3]) # [1, 2]
print(my_list[2 : 4]) # [2, 3]
```

Заметили, что это похоже на `range()`? Снова включаем левую границу и не включаем правую.

А что, если не написать левую границу? Она станет нулём!

```python
my_list = [0, 1, 2, 3, 4, 5, 6]
print(my_list[ : 4]) # [0, 1, 2, 3]
print(my_list[ : 3]) # [0, 1, 2]
```

А если не написать правую? 

```python
my_list = [0, 1, 2, 3, 4, 5, 6]
print(my_list[1 : ]) # [1, 2, 3, 4, 5, 6]
print(my_list[2 : ]) # [2, 3, 4, 5, 6]
```

Не написать обе?

```python
my_list = [0, 1, 2, 3, 4, 5, 6]
print(my_list[1 : ]) # [0, 1, 2, 3, 4, 5, 6]
```

А теперь вы точно заметите, что эта конструкция - один в один `range()` для цикла `for`

```python
my_list = [0, 1, 2, 3, 4, 5, 6]
print(my_list[1 : 4 : 2]) # [1, 3]
print(my_list[2 : 4 : 2]) # [2]
```

Поиграть с отрицательным шагом остаётся вам в качестве упражнения. Как, например, отработает такое?

```python
my_list = [0, 1, 2, 3, 4, 5, 6]
print(my_list[1 : 4 : -1])
print(my_list[5 : 2 : -2])
```

Но одна подсказка тут всё-таки будет. Перевернём список!

```python
my_list = [0, 1, 2, 3, 4, 5, 6]
print(my_list[ : : -1]) # [6, 5, 4, 3, 2, 1, 0]
```

## Внешние библиотеки

У python очень богатая *стандартная библиотека*. Это значит, что разработчики позаботились о программистах и сразу добавили кучу всего, чтобы не нужно было писать это самим

Например, вычисление квадратного корня или синуса угла.

```python
import math

root4 = math.sqrt(4) # 2.0
root2 = math.sqrt(2) # 1.4142135623730951

sin3 = math.sin(3) # 0.1411200080598672
# 3 - это значение в радианах! это не градусы!

print(math.pi) # 3.141592653589793
```

Когда мы написали `import math`, мы добавили всё, что было в модуле `math` в нашу программу. Но бывает, что нам не нужно *всё*, нам нужно только *что-то*

В следующем примере прямо попросим, чтобы нам добавили **только** `sqrt()`
```python
from math import sqrt
root2 = sqrt(2) # 1.4142135623730951
```

Снова похоже на английский: `из math импортируй sqrt`

Кстати, теперь нам не нужно было писать `math.sqrt()`, а просто `sqrt()`! Это сделано для того, чтобы вы не путались, если вдруг добавляете много модулей. Python сам не смог бы разобраться, из какого модуля вы хотите использовать `sqrt()`

Конечно, можно добавить всё сразу. **МОЖНО, НО НЕ НУЖНО!**

```python
from math import *
root2 = sqrt(2) # 1.4142135623730951
print(pi) # 3.141592653589793
```

Сейчас может быть не очень понятно, почему плохо так делать. 

Представьте, что у вас есть программа на 5 тысяч строчек кода и вдруг в ней появляется `pi`. Как быстро вы поймете, что это число ПИ? А если бы это было не `pi`, а какая-то хитрая функция с хитрым названием? 

А еще бывают ситуации, когда в двух разных модулях есть функции с одинаковым названием, но разным назначением. Тогда python может сломаться и применить не ту, которую вы хотели. Будет очень сложно найти ошибку!